#!/usr/bin/env python3
"""
Stitch track_follow images into a single mosaic using pixel-space metadata.

Reads satellite_images/track_follow/metadata.csv generated by
hungaroring_track_follow_capture.py and pastes each tile at its correct
position using Web Mercator pixel bounds. Any missing areas remain
transparent.

Output:
  satellite_images/track_follow/track_follow_mosaic.png
"""

import os
import csv
from typing import List, Dict, Tuple
from PIL import Image

META_CSV = os.path.join("satellite_images", "track_follow", "metadata.csv")
IMG_DIR = os.path.join("satellite_images", "track_follow")
OUT_PATH = os.path.join("satellite_images", "track_follow", "track_follow_mosaic.png")

# IMPORTANT: coordinates in metadata (left/top/right/bottom) are "world pixels" at the chosen zoom.
# Static Maps 'scale' returns higher resolution for the SAME geographic footprint.
# For size=640 and scale=2, returned image is 1280x1280 pixels covering 640 world pixels per side.
# Therefore, we must multiply metadata coordinates by SCALE when placing 1280px images on a pixel canvas.
SCALE = 2


def read_metadata(path: str) -> List[Dict[str, str]]:
    rows: List[Dict[str, str]] = []
    with open(path, "r") as f:
        reader = csv.DictReader(f)
        for r in reader:
            rows.append(r)
    return rows


def compute_canvas_bounds(rows: List[Dict[str, str]]) -> Tuple[float, float, float, float]:
    # min left, min top, max right, max bottom in Web Mercator pixel space
    lefts = [float(r["left"]) for r in rows]
    tops = [float(r["top"]) for r in rows]
    rights = [float(r["right"]) for r in rows]
    bottoms = [float(r["bottom"]) for r in rows]
    return (min(lefts), min(tops), max(rights), max(bottoms))


def main():
    if not os.path.exists(META_CSV):
        print(f"Metadata not found: {META_CSV}")
        return

    rows = read_metadata(META_CSV)
    if not rows:
        print("No metadata rows found")
        return

    min_left, min_top, max_right, max_bottom = compute_canvas_bounds(rows)

    # Normalize so top-left of canvas is (0,0), scaled to output pixel space
    width_px = int(round((max_right - min_left) * SCALE))
    height_px = int(round((max_bottom - min_top) * SCALE))

    # Create transparent canvas
    mosaic = Image.new("RGBA", (width_px, height_px), (0, 0, 0, 0))

    placed = 0
    for r in rows:
        filename = r["filename"]
        img_path = os.path.join(IMG_DIR, filename)
        if not os.path.exists(img_path):
            print(f"Missing tile: {filename}")
            continue

        # Compute where to paste this tile relative to top-left
        left = (float(r["left"]) - min_left) * SCALE
        top = (float(r["top"]) - min_top) * SCALE

        # Round to integers for paste position
        x = int(round(left))
        y = int(round(top))

        try:
            img = Image.open(img_path).convert("RGBA")
            # Safety: tile may not be exactly TILE_PIXEL_SIZE due to API; use actual size
            mosaic.alpha_composite(img, (x, y))
            placed += 1
        except Exception as e:
            print(f"Error placing {filename}: {e}")

    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)
    mosaic.save(OUT_PATH)
    print(f"Mosaic saved: {OUT_PATH} ({width_px}x{height_px}), tiles placed: {placed}/{len(rows)})")


if __name__ == "__main__":
    main()
